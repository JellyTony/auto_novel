# 流式章节生成技术实现方案

## 1. 项目概述

本文档详细说明如何将现有的章节生成接口从传统的一次性响应改为流式输出实现，并在前端添加逐字显示的打字机交互效果，以提升用户体验和实时反馈。

### 1.1 技术背景
- **后端框架**：Go + Kratos v2.8.0 + gRPC/HTTP双协议
- **前端框架**：Next.js 15.5.4 + React 19.1.0 + TypeScript
- **AI框架**：cloudwego/eino v0.5.3
- **现有接口**：GenerateChapter (非流式)

### 1.2 改造目标
- 将章节生成改为流式输出，实时返回生成内容
- 前端实现逐字显示的打字机效果
- 保持良好的用户体验和完善的错误处理
- 支持生成过程中的取消操作

## 2. 后端流式接口设计

### 2.1 Protobuf 接口定义修改

#### 2.1.1 新增流式响应消息类型

```protobuf
// 流式章节生成响应
message GenerateChapterStreamResponse {
  // 响应类型
  enum ResponseType {
    CONTENT = 0;    // 内容片段
    PROGRESS = 1;   // 进度更新
    METADATA = 2;   // 元数据信息
    ERROR = 3;      // 错误信息
    COMPLETE = 4;   // 生成完成
  }
  
  ResponseType type = 1;
  
  // 内容相关字段
  string content_chunk = 2;      // 内容片段
  int32 chunk_index = 3;         // 片段索引
  
  // 进度相关字段
  float progress = 4;            // 进度百分比 (0-1)
  string stage = 5;              // 当前阶段描述
  
  // 元数据字段
  string chapter_id = 6;         // 章节ID
  string title = 7;              // 章节标题
  int32 word_count = 8;          // 当前字数
  
  // 错误信息
  string error_message = 9;      // 错误描述
  string error_code = 10;        // 错误代码
  
  // 完成信息
  Chapter final_chapter = 11;    // 最终章节对象
}
```

#### 2.1.2 修改服务定义

```protobuf
service NovelService {
  // 流式生成章节内容
  rpc GenerateChapterStream (GenerateChapterRequest) returns (stream GenerateChapterStreamResponse) {
    option (google.api.http) = {
      post: "/api/v1/novel/projects/{project_id}/chapters/stream"
      body: "*"
    };
  }
  
  // 保留原有接口用于兼容性
  rpc GenerateChapter (GenerateChapterRequest) returns (GenerateChapterResponse) {
    option (google.api.http) = {
      post: "/api/v1/novel/projects/{project_id}/chapters"
      body: "*"
    };
  }
}
```

### 2.2 后端服务实现

#### 2.2.1 流式服务方法实现

```go
// GenerateChapterStream 流式生成章节
func (s *NovelService) GenerateChapterStream(req *pb.GenerateChapterRequest, stream pb.NovelService_GenerateChapterStreamServer) error {
    ctx := stream.Context()
    
    // 发送开始信号
    if err := stream.Send(&pb.GenerateChapterStreamResponse{
        Type:    pb.GenerateChapterStreamResponse_PROGRESS,
        Progress: 0.0,
        Stage:   "开始生成章节...",
    }); err != nil {
        return err
    }
    
    // 构建生成请求
    chapterReq := &chapter.GenerateChapterRequest{
        ProjectID:       req.ProjectId,
        ChapterOutline:  convertChapterOutlineFromProto(req.ChapterOutline),
        Context:         convertContextFromProto(req.Context),
        TargetWordCount: int(req.TargetWordCount),
        Options:         convertLLMOptionsFromProto(req.LlmOptions),
    }
    
    // 创建流式生成回调
    callback := &StreamCallback{
        stream: stream,
        chapterID: generateChapterID(),
        title: req.ChapterOutline.Title,
    }
    
    // 执行流式生成
    chapter, err := s.chapterAgent.GenerateChapterStream(ctx, chapterReq, callback)
    if err != nil {
        // 发送错误信息
        return stream.Send(&pb.GenerateChapterStreamResponse{
            Type:         pb.GenerateChapterStreamResponse_ERROR,
            ErrorMessage: err.Error(),
            ErrorCode:    "GENERATION_FAILED",
        })
    }
    
    // 保存章节
    savedChapter, err := s.uc.SaveChapter(ctx, chapter)
    if err != nil {
        return stream.Send(&pb.GenerateChapterStreamResponse{
            Type:         pb.GenerateChapterStreamResponse_ERROR,
            ErrorMessage: "保存章节失败",
            ErrorCode:    "SAVE_FAILED",
        })
    }
    
    // 发送完成信号
    return stream.Send(&pb.GenerateChapterStreamResponse{
        Type:          pb.GenerateChapterStreamResponse_COMPLETE,
        Progress:      1.0,
        FinalChapter:  convertChapterToProto(savedChapter),
    })
}
```

#### 2.2.2 流式回调处理器

```go
// StreamCallback 流式生成回调处理器
type StreamCallback struct {
    stream    pb.NovelService_GenerateChapterStreamServer
    chapterID string
    title     string
    wordCount int32
    chunkIndex int32
}

// OnContentChunk 处理内容片段
func (c *StreamCallback) OnContentChunk(content string) error {
    c.chunkIndex++
    c.wordCount += int32(len([]rune(content)))
    
    return c.stream.Send(&pb.GenerateChapterStreamResponse{
        Type:         pb.GenerateChapterStreamResponse_CONTENT,
        ContentChunk: content,
        ChunkIndex:   c.chunkIndex,
        ChapterId:    c.chapterID,
        Title:        c.title,
        WordCount:    c.wordCount,
    })
}

// OnProgress 处理进度更新
func (c *StreamCallback) OnProgress(progress float32, stage string) error {
    return c.stream.Send(&pb.GenerateChapterStreamResponse{
        Type:     pb.GenerateChapterStreamResponse_PROGRESS,
        Progress: progress,
        Stage:    stage,
    })
}
```

#### 2.2.3 AI Agent 流式生成实现

```go
// GenerateChapterStream 流式生成章节内容
func (a *EinoChapterAgent) GenerateChapterStream(ctx context.Context, req *GenerateChapterRequest, callback StreamCallback) (*models.Chapter, error) {
    // 构建提示词
    prompt := a.buildChapterPrompt(req)
    
    // 创建流式生成选项
    options := &eino.GenerateOptions{
        Temperature: req.Options.Temperature,
        MaxTokens:   req.Options.MaxTokens,
        Stream:      true,
    }
    
    // 执行流式生成
    var fullContent strings.Builder
    err := a.client.GenerateTextStream(ctx, prompt, options, func(chunk string) error {
        fullContent.WriteString(chunk)
        return callback.OnContentChunk(chunk)
    })
    
    if err != nil {
        return nil, fmt.Errorf("流式生成失败: %w", err)
    }
    
    // 构建章节对象
    chapter := &models.Chapter{
        ID:           generateChapterID(),
        ProjectID:    req.ProjectID,
        Title:        req.ChapterOutline.Title,
        Content:      fullContent.String(),
        WordCount:    len([]rune(fullContent.String())),
        Status:       "completed",
        CreatedAt:    time.Now(),
        UpdatedAt:    time.Now(),
    }
    
    return chapter, nil
}
```

### 2.3 HTTP 流式支持

#### 2.3.1 HTTP 流式处理器

```go
// GenerateChapterStreamHTTP HTTP流式章节生成
func (s *NovelService) GenerateChapterStreamHTTP(ctx http.Context) error {
    var req pb.GenerateChapterRequest
    if err := ctx.Bind(&req); err != nil {
        return err
    }
    
    // 设置SSE头部
    ctx.Header("Content-Type", "text/event-stream")
    ctx.Header("Cache-Control", "no-cache")
    ctx.Header("Connection", "keep-alive")
    ctx.Header("Access-Control-Allow-Origin", "*")
    
    // 创建流式写入器
    writer := &SSEWriter{ctx: ctx}
    
    // 执行生成逻辑
    return s.generateChapterWithSSE(ctx.Request.Context(), &req, writer)
}

// SSEWriter Server-Sent Events 写入器
type SSEWriter struct {
    ctx http.Context
}

func (w *SSEWriter) WriteEvent(eventType, data string) error {
    event := fmt.Sprintf("event: %s\ndata: %s\n\n", eventType, data)
    _, err := w.ctx.Writer().Write([]byte(event))
    if err != nil {
        return err
    }
    w.ctx.Writer().Flush()
    return nil
}
```

## 3. 前端流式数据接收和处理

### 3.1 API 客户端实现

#### 3.1.1 流式API客户端

```typescript
// 流式章节生成响应类型
interface GenerateChapterStreamResponse {
  type: 'CONTENT' | 'PROGRESS' | 'METADATA' | 'ERROR' | 'COMPLETE';
  content_chunk?: string;
  chunk_index?: number;
  progress?: number;
  stage?: string;
  chapter_id?: string;
  title?: string;
  word_count?: number;
  error_message?: string;
  error_code?: string;
  final_chapter?: Chapter;
}

// 流式生成回调接口
interface StreamCallbacks {
  onContent: (chunk: string, metadata: { chunkIndex: number; wordCount: number }) => void;
  onProgress: (progress: number, stage: string) => void;
  onError: (error: string, code?: string) => void;
  onComplete: (chapter: Chapter) => void;
}

// 流式API客户端
class StreamingAPI {
  // 流式生成章节
  static async generateChapterStream(
    request: GenerateChapterRequest,
    callbacks: StreamCallbacks,
    signal?: AbortSignal
  ): Promise<void> {
    const url = `/api/v1/novel/projects/${request.project_id}/chapters/stream`;
    
    try {
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'text/event-stream',
        },
        body: JSON.stringify(request),
        signal,
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const reader = response.body?.getReader();
      if (!reader) {
        throw new Error('无法获取响应流');
      }

      const decoder = new TextDecoder();
      let buffer = '';

      while (true) {
        const { done, value } = await reader.read();
        
        if (done) break;
        
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            try {
              const data: GenerateChapterStreamResponse = JSON.parse(line.slice(6));
              this.handleStreamResponse(data, callbacks);
            } catch (error) {
              console.error('解析流式数据失败:', error);
            }
          }
        }
      }
    } catch (error) {
      if (error instanceof Error) {
        callbacks.onError(error.message);
      }
    }
  }

  private static handleStreamResponse(
    data: GenerateChapterStreamResponse,
    callbacks: StreamCallbacks
  ) {
    switch (data.type) {
      case 'CONTENT':
        if (data.content_chunk) {
          callbacks.onContent(data.content_chunk, {
            chunkIndex: data.chunk_index || 0,
            wordCount: data.word_count || 0,
          });
        }
        break;
      
      case 'PROGRESS':
        callbacks.onProgress(data.progress || 0, data.stage || '');
        break;
      
      case 'ERROR':
        callbacks.onError(data.error_message || '未知错误', data.error_code);
        break;
      
      case 'COMPLETE':
        if (data.final_chapter) {
          callbacks.onComplete(data.final_chapter);
        }
        break;
    }
  }
}
```

### 3.2 React Hook 实现

#### 3.2.1 流式生成Hook

```typescript
// 流式生成状态
interface StreamingState {
  isStreaming: boolean;
  content: string;
  progress: number;
  stage: string;
  wordCount: number;
  error: string | null;
  chapter: Chapter | null;
}

// 流式生成Hook
export function useStreamingGeneration() {
  const [state, setState] = useState<StreamingState>({
    isStreaming: false,
    content: '',
    progress: 0,
    stage: '',
    wordCount: 0,
    error: null,
    chapter: null,
  });

  const [abortController, setAbortController] = useState<AbortController | null>(null);

  const startGeneration = useCallback(async (request: GenerateChapterRequest) => {
    // 重置状态
    setState({
      isStreaming: true,
      content: '',
      progress: 0,
      stage: '准备生成...',
      wordCount: 0,
      error: null,
      chapter: null,
    });

    // 创建取消控制器
    const controller = new AbortController();
    setAbortController(controller);

    const callbacks: StreamCallbacks = {
      onContent: (chunk, metadata) => {
        setState(prev => ({
          ...prev,
          content: prev.content + chunk,
          wordCount: metadata.wordCount,
        }));
      },

      onProgress: (progress, stage) => {
        setState(prev => ({
          ...prev,
          progress,
          stage,
        }));
      },

      onError: (error, code) => {
        setState(prev => ({
          ...prev,
          isStreaming: false,
          error: error,
        }));
        setAbortController(null);
      },

      onComplete: (chapter) => {
        setState(prev => ({
          ...prev,
          isStreaming: false,
          chapter,
          progress: 1,
          stage: '生成完成',
        }));
        setAbortController(null);
      },
    };

    try {
      await StreamingAPI.generateChapterStream(request, callbacks, controller.signal);
    } catch (error) {
      if (error instanceof Error && error.name !== 'AbortError') {
        setState(prev => ({
          ...prev,
          isStreaming: false,
          error: error.message,
        }));
      }
      setAbortController(null);
    }
  }, []);

  const cancelGeneration = useCallback(() => {
    if (abortController) {
      abortController.abort();
      setAbortController(null);
      setState(prev => ({
        ...prev,
        isStreaming: false,
        stage: '已取消',
      }));
    }
  }, [abortController]);

  return {
    ...state,
    startGeneration,
    cancelGeneration,
    canCancel: !!abortController,
  };
}
```

## 4. 逐字显示的打字机效果实现

### 4.1 打字机组件实现

```typescript
interface TypewriterProps {
  text: string;
  speed?: number;
  onComplete?: () => void;
  className?: string;
}

export function Typewriter({ text, speed = 50, onComplete, className }: TypewriterProps) {
  const [displayText, setDisplayText] = useState('');
  const [currentIndex, setCurrentIndex] = useState(0);
  const [isTyping, setIsTyping] = useState(false);

  useEffect(() => {
    if (currentIndex < text.length) {
      setIsTyping(true);
      const timer = setTimeout(() => {
        setDisplayText(prev => prev + text[currentIndex]);
        setCurrentIndex(prev => prev + 1);
      }, speed);

      return () => clearTimeout(timer);
    } else if (currentIndex === text.length && isTyping) {
      setIsTyping(false);
      onComplete?.();
    }
  }, [text, currentIndex, speed, onComplete, isTyping]);

  // 当文本变化时重置状态
  useEffect(() => {
    if (text.length < displayText.length) {
      setDisplayText(text);
      setCurrentIndex(text.length);
    }
  }, [text, displayText.length]);

  return (
    <div className={className}>
      <span>{displayText}</span>
      {isTyping && (
        <span className="animate-pulse ml-1 text-blue-500">|</span>
      )}
    </div>
  );
}
```

### 4.2 流式内容显示组件

```typescript
interface StreamingContentProps {
  content: string;
  isStreaming: boolean;
  typewriterSpeed?: number;
}

export function StreamingContent({ 
  content, 
  isStreaming, 
  typewriterSpeed = 30 
}: StreamingContentProps) {
  const [displayContent, setDisplayContent] = useState('');
  const [pendingContent, setPendingContent] = useState('');
  const [isTyping, setIsTyping] = useState(false);

  // 处理新内容到达
  useEffect(() => {
    if (content.length > displayContent.length) {
      const newContent = content.slice(displayContent.length);
      setPendingContent(prev => prev + newContent);
    }
  }, [content, displayContent.length]);

  // 打字机效果处理
  useEffect(() => {
    if (pendingContent && !isTyping) {
      setIsTyping(true);
      const timer = setInterval(() => {
        setPendingContent(prev => {
          if (prev.length === 0) {
            setIsTyping(false);
            clearInterval(timer);
            return '';
          }
          
          const nextChar = prev[0];
          setDisplayContent(current => current + nextChar);
          return prev.slice(1);
        });
      }, typewriterSpeed);

      return () => clearInterval(timer);
    }
  }, [pendingContent, isTyping, typewriterSpeed]);

  return (
    <div className="relative">
      <div className="whitespace-pre-wrap leading-relaxed">
        {displayContent}
        {(isTyping || isStreaming) && (
          <span className="animate-pulse ml-1 text-blue-500 font-bold">|</span>
        )}
      </div>
      
      {/* 进度指示器 */}
      {isStreaming && (
        <div className="absolute bottom-0 right-0 flex items-center gap-2 text-sm text-gray-500">
          <div className="flex space-x-1">
            <div className="w-2 h-2 bg-blue-500 rounded-full animate-bounce"></div>
            <div className="w-2 h-2 bg-blue-500 rounded-full animate-bounce" style={{ animationDelay: '0.1s' }}></div>
            <div className="w-2 h-2 bg-blue-500 rounded-full animate-bounce" style={{ animationDelay: '0.2s' }}></div>
          </div>
          <span>AI正在创作中...</span>
        </div>
      )}
    </div>
  );
}
```

## 5. 用户界面优化

### 5.1 章节生成对话框组件

```typescript
interface ChapterGenerationDialogProps {
  isOpen: boolean;
  onClose: () => void;
  chapterOutline: ChapterOutline;
  projectId: string;
}

export function ChapterGenerationDialog({
  isOpen,
  onClose,
  chapterOutline,
  projectId
}: ChapterGenerationDialogProps) {
  const {
    content,
    progress,
    stage,
    wordCount,
    error,
    chapter,
    isStreaming,
    startGeneration,
    cancelGeneration,
    canCancel
  } = useStreamingGeneration();

  const handleStartGeneration = () => {
    const request: GenerateChapterRequest = {
      project_id: projectId,
      chapter_number: chapterOutline.index,
      outline: chapterOutline,
      target_word_count: 2000,
    };
    
    startGeneration(request);
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-hidden flex flex-col">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <PenTool className="h-5 w-5" />
            {chapterOutline.title}
          </DialogTitle>
          <DialogDescription>
            AI正在为您创作章节内容，请耐心等待...
          </DialogDescription>
        </DialogHeader>

        {/* 进度条 */}
        {isStreaming && (
          <div className="space-y-2">
            <div className="flex justify-between text-sm">
              <span>{stage}</span>
              <span>{Math.round(progress * 100)}%</span>
            </div>
            <Progress value={progress * 100} className="h-2" />
            <div className="flex justify-between text-xs text-gray-500">
              <span>已生成 {wordCount} 字</span>
              <span>预计目标 2000 字</span>
            </div>
          </div>
        )}

        {/* 内容显示区域 */}
        <div className="flex-1 overflow-y-auto border rounded-lg p-4 bg-gray-50 min-h-[400px]">
          {!content && !isStreaming && !error && (
            <div className="flex items-center justify-center h-full text-gray-500">
              <div className="text-center space-y-4">
                <FileText className="h-12 w-12 mx-auto text-gray-400" />
                <p>点击开始生成按钮开始创作</p>
              </div>
            </div>
          )}

          {error && (
            <div className="flex items-center justify-center h-full">
              <div className="text-center space-y-4 text-red-500">
                <AlertCircle className="h-12 w-12 mx-auto" />
                <p>生成失败：{error}</p>
                <Button onClick={handleStartGeneration} variant="outline">
                  重试
                </Button>
              </div>
            </div>
          )}

          {(content || isStreaming) && (
            <StreamingContent
              content={content}
              isStreaming={isStreaming}
              typewriterSpeed={30}
            />
          )}
        </div>

        {/* 操作按钮 */}
        <DialogFooter className="flex justify-between">
          <div className="flex gap-2">
            {!isStreaming && !content && (
              <Button onClick={handleStartGeneration} className="flex items-center gap-2">
                <Sparkles className="h-4 w-4" />
                开始生成
              </Button>
            )}
            
            {canCancel && (
              <Button onClick={cancelGeneration} variant="destructive">
                <X className="h-4 w-4 mr-2" />
                取消生成
              </Button>
            )}
          </div>

          <div className="flex gap-2">
            {chapter && (
              <Button onClick={() => {
                toast.success('章节已保存');
                onClose();
              }}>
                <Save className="h-4 w-4 mr-2" />
                保存章节
              </Button>
            )}
            
            <Button variant="outline" onClick={onClose}>
              关闭
            </Button>
          </div>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
```

### 5.2 修改原有的开始写作按钮

```typescript
// 在 outline/page.tsx 中修改 handleStartWriting 函数
const [showGenerationDialog, setShowGenerationDialog] = useState(false);
const [selectedChapterOutline, setSelectedChapterOutline] = useState<ChapterOutline | null>(null);

const handleStartWriting = (chapterIndex: number) => {
  if (!selectedProject) {
    toast.error('请先选择项目');
    return;
  }
  
  const outline = chapters.find(c => c.index === chapterIndex);
  if (!outline) {
    toast.error('未找到对应的章节大纲');
    return;
  }
  
  setSelectedChapterOutline(outline);
  setShowGenerationDialog(true);
};

// 在组件返回的JSX中添加对话框
return (
  <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100">
    {/* 现有内容 */}
    
    {/* 章节生成对话框 */}
    {selectedChapterOutline && (
      <ChapterGenerationDialog
        isOpen={showGenerationDialog}
        onClose={() => {
          setShowGenerationDialog(false);
          setSelectedChapterOutline(null);
        }}
        chapterOutline={selectedChapterOutline}
        projectId={selectedProject}
      />
    )}
  </div>
);
```

## 6. 错误处理和用户体验优化

### 6.1 错误处理策略

```typescript
// 错误类型定义
enum StreamErrorType {
  NETWORK_ERROR = 'NETWORK_ERROR',
  GENERATION_FAILED = 'GENERATION_FAILED',
  SAVE_FAILED = 'SAVE_FAILED',
  TIMEOUT = 'TIMEOUT',
  CANCELLED = 'CANCELLED'
}

// 错误处理工具
class StreamErrorHandler {
  static getErrorMessage(error: string, code?: string): string {
    switch (code) {
      case StreamErrorType.NETWORK_ERROR:
        return '网络连接失败，请检查网络设置后重试';
      case StreamErrorType.GENERATION_FAILED:
        return 'AI生成失败，请稍后重试或调整生成参数';
      case StreamErrorType.SAVE_FAILED:
        return '章节保存失败，请重试';
      case StreamErrorType.TIMEOUT:
        return '生成超时，请重试';
      case StreamErrorType.CANCELLED:
        return '生成已取消';
      default:
        return error || '未知错误';
    }
  }

  static shouldRetry(code?: string): boolean {
    return [
      StreamErrorType.NETWORK_ERROR,
      StreamErrorType.GENERATION_FAILED,
      StreamErrorType.TIMEOUT
    ].includes(code as StreamErrorType);
  }
}
```

### 6.2 性能优化

```typescript
// 内容缓冲优化
class ContentBuffer {
  private buffer: string[] = [];
  private flushTimer: NodeJS.Timeout | null = null;
  private onFlush: (content: string) => void;

  constructor(onFlush: (content: string) => void, flushInterval = 100) {
    this.onFlush = onFlush;
  }

  add(chunk: string) {
    this.buffer.push(chunk);
    
    if (this.flushTimer) {
      clearTimeout(this.flushTimer);
    }
    
    this.flushTimer = setTimeout(() => {
      this.flush();
    }, 100);
  }

  flush() {
    if (this.buffer.length > 0) {
      const content = this.buffer.join('');
      this.buffer = [];
      this.onFlush(content);
    }
    
    if (this.flushTimer) {
      clearTimeout(this.flushTimer);
      this.flushTimer = null;
    }
  }
}
```

### 6.3 用户体验增强

```typescript
// 生成统计信息
interface GenerationStats {
  startTime: number;
  endTime?: number;
  totalWords: number;
  averageSpeed: number; // 字/秒
  chunks: number;
}

// 统计Hook
export function useGenerationStats() {
  const [stats, setStats] = useState<GenerationStats>({
    startTime: 0,
    totalWords: 0,
    averageSpeed: 0,
    chunks: 0,
  });

  const startTracking = useCallback(() => {
    setStats({
      startTime: Date.now(),
      totalWords: 0,
      averageSpeed: 0,
      chunks: 0,
    });
  }, []);

  const updateStats = useCallback((wordCount: number, chunkCount: number) => {
    setStats(prev => {
      const elapsed = (Date.now() - prev.startTime) / 1000;
      const averageSpeed = elapsed > 0 ? wordCount / elapsed : 0;
      
      return {
        ...prev,
        totalWords: wordCount,
        averageSpeed,
        chunks: chunkCount,
      };
    });
  }, []);

  const finishTracking = useCallback(() => {
    setStats(prev => ({
      ...prev,
      endTime: Date.now(),
    }));
  }, []);

  return {
    stats,
    startTracking,
    updateStats,
    finishTracking,
  };
}
```

## 7. 部署和配置

### 7.1 后端配置

```yaml
# config.yaml
server:
  http:
    addr: 0.0.0.0:8000
    timeout: 600s
    # 流式响应配置
    stream:
      buffer_size: 1024
      flush_interval: 100ms
  grpc:
    addr: 0.0.0.0:9000
    timeout: 600s

ai:
  models:
    default:
      provider: "deepseek"
      model_name: "deepseek-chat"
      api_key: "your-api-key"
      base_url: "https://api.deepseek.com/"
      temperature: 0.8
      max_tokens: 4096
      # 流式生成配置
      stream: true
      chunk_size: 50
```

### 7.2 前端环境变量

```bash
# .env.local
NEXT_PUBLIC_API_URL=http://localhost:8000
NEXT_PUBLIC_STREAM_TIMEOUT=300000
NEXT_PUBLIC_TYPEWRITER_SPEED=30
```

## 8. 测试方案

### 8.1 后端测试

```go
// 流式生成测试
func TestGenerateChapterStream(t *testing.T) {
    // 创建测试服务
    service := setupTestService()
    
    // 创建测试请求
    req := &pb.GenerateChapterRequest{
        ProjectId: "test-project",
        ChapterOutline: &pb.ChapterOutline{
            Title: "测试章节",
            Summary: "测试章节概要",
        },
    }
    
    // 创建模拟流
    stream := &mockStream{}
    
    // 执行测试
    err := service.GenerateChapterStream(req, stream)
    assert.NoError(t, err)
    
    // 验证响应
    assert.True(t, stream.hasContentChunks())
    assert.True(t, stream.hasProgressUpdates())
    assert.True(t, stream.hasCompletion())
}
```

### 8.2 前端测试

```typescript
// 流式生成Hook测试
describe('useStreamingGeneration', () => {
  it('should handle streaming content correctly', async () => {
    const { result } = renderHook(() => useStreamingGeneration());
    
    // 模拟开始生成
    await act(async () => {
      await result.current.startGeneration(mockRequest);
    });
    
    expect(result.current.isStreaming).toBe(true);
    expect(result.current.content).toBe('');
    
    // 模拟接收内容
    // ... 测试逻辑
  });
});
```

## 9. 总结

本技术方案详细说明了如何将现有的章节生成接口改造为流式输出实现，主要改进包括：

1. **后端流式接口**：基于 gRPC Stream 和 HTTP SSE 实现双协议支持
2. **前端流式处理**：使用 Fetch API 和 ReadableStream 处理流式数据
3. **打字机效果**：实现逐字显示的视觉效果，提升用户体验
4. **错误处理**：完善的错误处理和重试机制
5. **性能优化**：内容缓冲和批量更新优化
6. **用户体验**：进度显示、取消操作、统计信息等

通过这些改进，用户可以实时看到AI生成的内容，获得更好的交互体验和反馈。