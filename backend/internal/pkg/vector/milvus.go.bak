package vector

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/milvus-io/milvus-sdk-go/v2/client"
	"github.com/milvus-io/milvus-sdk-go/v2/entity"
)

// MilvusConfig Milvus 配置
type MilvusConfig struct {
	Host     string `json:"host"`
	Port     int    `json:"port"`
	Username string `json:"username"`
	Password string `json:"password"`
	Database string `json:"database"`
}

// MilvusClient Milvus 客户端实现
type MilvusClient struct {
	client client.Client
	config *MilvusConfig
}

// NewMilvusClient 创建 Milvus 客户端
func NewMilvusClient(config *MilvusConfig) (*MilvusClient, error) {
	c, err := client.NewGrpcClient(context.Background(), fmt.Sprintf("%s:%d", config.Host, config.Port))
	if err != nil {
		return nil, fmt.Errorf("failed to connect to Milvus: %w", err)
	}

	// 认证（如果需要）
	if config.Username != "" && config.Password != "" {
		err = c.Authenticate(context.Background(), config.Username, config.Password)
		if err != nil {
			return nil, fmt.Errorf("failed to authenticate: %w", err)
		}
	}

	return &MilvusClient{
		client: c,
		config: config,
	}, nil
}

// CreateCollection 创建集合
func (m *MilvusClient) CreateCollection(ctx context.Context, name string, dimension int) error {
	// 检查集合是否已存在
	exists, err := m.client.HasCollection(ctx, name)
	if err != nil {
		return fmt.Errorf("failed to check collection existence: %w", err)
	}

	if exists {
		log.Printf("Collection %s already exists", name)
		return nil
	}

	// 定义字段
	fields := []*entity.Field{
		{
			Name:       "id",
			DataType:   entity.FieldTypeVarChar,
			PrimaryKey: true,
			AutoID:     false,
			TypeParams: map[string]string{
				"max_length": "255",
			},
		},
		{
			Name:     "content",
			DataType: entity.FieldTypeVarChar,
			TypeParams: map[string]string{
				"max_length": "65535",
			},
		},
		{
			Name:     "embedding",
			DataType: entity.FieldTypeFloatVector,
			TypeParams: map[string]string{
				"dim": fmt.Sprintf("%d", dimension),
			},
		},
		{
			Name:     "metadata",
			DataType: entity.FieldTypeJSON,
		},
		{
			Name:     "created_at",
			DataType: entity.FieldTypeInt64,
		},
	}

	// 创建 schema
	schema := &entity.Schema{
		CollectionName: name,
		Description:    fmt.Sprintf("Collection for %s documents", name),
		Fields:         fields,
	}

	// 创建集合
	err = m.client.CreateCollection(ctx, schema, entity.DefaultShardNumber)
	if err != nil {
		return fmt.Errorf("failed to create collection: %w", err)
	}

	// 创建索引
	indexParams := entity.NewIndexHNSWParams(entity.L2, 16, 200)
	err = m.client.CreateIndex(ctx, name, "embedding", indexParams, false)
	if err != nil {
		return fmt.Errorf("failed to create index: %w", err)
	}

	// 加载集合
	err = m.client.LoadCollection(ctx, name, false)
	if err != nil {
		return fmt.Errorf("failed to load collection: %w", err)
	}

	return nil
}

// DeleteCollection 删除集合
func (m *MilvusClient) DeleteCollection(ctx context.Context, name string) error {
	return m.client.DropCollection(ctx, name)
}

// ListCollections 列出所有集合
func (m *MilvusClient) ListCollections(ctx context.Context) ([]string, error) {
	collections, err := m.client.ListCollections(ctx)
	if err != nil {
		return nil, err
	}

	names := make([]string, len(collections))
	for i, collection := range collections {
		names[i] = collection.Name
	}

	return names, nil
}

// AddDocument 添加文档
func (m *MilvusClient) AddDocument(ctx context.Context, doc *Document) error {
	return m.BatchAdd(ctx, []*Document{doc})
}

// UpdateDocument 更新文档（先删除再添加）
func (m *MilvusClient) UpdateDocument(ctx context.Context, doc *Document) error {
	// 先删除旧文档
	err := m.DeleteDocument(ctx, doc.ID)
	if err != nil {
		log.Printf("Warning: failed to delete old document %s: %v", doc.ID, err)
	}

	// 添加新文档
	return m.AddDocument(ctx, doc)
}

// DeleteDocument 删除文档
func (m *MilvusClient) DeleteDocument(ctx context.Context, id string) error {
	return m.BatchDelete(ctx, []string{id})
}

// GetDocument 获取文档
func (m *MilvusClient) GetDocument(ctx context.Context, id string) (*Document, error) {
	// Milvus 不直接支持按 ID 查询，需要使用 query
	// 这里简化实现，实际使用中可能需要更复杂的查询逻辑
	return nil, fmt.Errorf("GetDocument not implemented for Milvus")
}

// BatchAdd 批量添加文档
func (m *MilvusClient) BatchAdd(ctx context.Context, docs []*Document) error {
	if len(docs) == 0 {
		return nil
	}

	collection := docs[0].Collection
	
	// 准备数据
	ids := make([]string, len(docs))
	contents := make([]string, len(docs))
	embeddings := make([][]float32, len(docs))
	metadatas := make([][]byte, len(docs))
	timestamps := make([]int64, len(docs))

	for i, doc := range docs {
		ids[i] = doc.ID
		contents[i] = doc.Content
		embeddings[i] = doc.Embedding
		
		// 序列化 metadata
		metadataBytes, err := serializeMetadata(doc.Metadata)
		if err != nil {
			return fmt.Errorf("failed to serialize metadata for doc %s: %w", doc.ID, err)
		}
		metadatas[i] = metadataBytes
		
		timestamps[i] = doc.CreatedAt.Unix()
	}

	// 创建列数据
	columns := []entity.Column{
		entity.NewColumnVarChar("id", ids),
		entity.NewColumnVarChar("content", contents),
		entity.NewColumnFloatVector("embedding", len(embeddings[0]), embeddings),
		entity.NewColumnJSONBytes("metadata", metadatas),
		entity.NewColumnInt64("created_at", timestamps),
	}

	// 插入数据
	_, err := m.client.Insert(ctx, collection, "", columns...)
	if err != nil {
		return fmt.Errorf("failed to insert documents: %w", err)
	}

	// 刷新数据
	err = m.client.Flush(ctx, collection, false)
	if err != nil {
		log.Printf("Warning: failed to flush collection %s: %v", collection, err)
	}

	return nil
}

// BatchDelete 批量删除文档
func (m *MilvusClient) BatchDelete(ctx context.Context, ids []string) error {
	if len(ids) == 0 {
		return nil
	}

	// 构建删除表达式
	expr := fmt.Sprintf("id in [%s]", formatStringList(ids))
	
	// 需要知道集合名，这里简化处理
	// 实际使用中可能需要传入集合名或者查询所有集合
	collections, err := m.ListCollections(ctx)
	if err != nil {
		return fmt.Errorf("failed to list collections: %w", err)
	}

	for _, collection := range collections {
		err = m.client.Delete(ctx, collection, "", expr)
		if err != nil {
			log.Printf("Warning: failed to delete from collection %s: %v", collection, err)
		}
	}

	return nil
}

// Search 搜索文档
func (m *MilvusClient) Search(ctx context.Context, query string, options *SearchOptions) ([]*SearchResult, error) {
	// 如果查询为空，返回空结果
	if query == "" && options.Filter == nil {
		return []*SearchResult{}, nil
	}

	// 生成查询向量（这里需要外部嵌入服务）
	// 实际使用中需要传入嵌入服务或者预先生成向量
	return nil, fmt.Errorf("Search requires embedding service integration")
}

// SimilaritySearch 相似度搜索
func (m *MilvusClient) SimilaritySearch(ctx context.Context, embedding []float32, options *SearchOptions) ([]*SearchResult, error) {
	// 构建搜索参数
	searchParams := entity.NewIndexHNSWSearchParam(40)
	
	// 构建过滤表达式
	expr := ""
	if options.Filter != nil {
		expr = buildFilterExpression(options.Filter)
	}

	// 执行搜索
	vectors := []entity.Vector{entity.FloatVector(embedding)}
	searchResult, err := m.client.Search(
		ctx,
		options.Collection,
		[]string{}, // 分区名
		expr,       // 过滤表达式
		[]string{"id", "content", "metadata", "created_at"}, // 输出字段
		vectors,
		"embedding", // 向量字段名
		entity.L2,   // 度量类型
		options.TopK,
		searchParams,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to search: %w", err)
	}

	// 转换结果
	results := make([]*SearchResult, 0)
	for _, result := range searchResult {
		for i := 0; i < result.ResultCount; i++ {
			score := result.Scores[i]
			if score < options.Threshold {
				continue
			}

			// 提取字段值
			id := result.Fields.GetColumn("id").(*entity.ColumnVarChar).Data()[i]
			content := result.Fields.GetColumn("content").(*entity.ColumnVarChar).Data()[i]
			metadataBytes := result.Fields.GetColumn("metadata").(*entity.ColumnJSONBytes).Data()[i]
			createdAt := result.Fields.GetColumn("created_at").(*entity.ColumnInt64).Data()[i]

			// 反序列化 metadata
			metadata, err := deserializeMetadata(metadataBytes)
			if err != nil {
				log.Printf("Warning: failed to deserialize metadata for doc %s: %v", id, err)
				metadata = make(map[string]interface{})
			}

			doc := &Document{
				ID:         id,
				Content:    content,
				Metadata:   metadata,
				Collection: options.Collection,
				CreatedAt:  time.Unix(createdAt, 0),
			}

			if options.IncludeEmbedding {
				doc.Embedding = embedding // 这里简化处理
			}

			results = append(results, &SearchResult{
				Document: doc,
				Score:    score,
				Distance: 1.0 - score, // L2 距离转换
			})
		}
	}

	return results, nil
}

// Ping 健康检查
func (m *MilvusClient) Ping(ctx context.Context) error {
	_, err := m.client.GetVersion(ctx)
	return err
}

// Close 关闭连接
func (m *MilvusClient) Close() error {
	return m.client.Close()
}

// 辅助函数
func serializeMetadata(metadata map[string]interface{}) ([]byte, error) {
	// 简化实现，实际可能需要使用 JSON 序列化
	return []byte("{}"), nil
}

func deserializeMetadata(data []byte) (map[string]interface{}, error) {
	// 简化实现，实际可能需要使用 JSON 反序列化
	return make(map[string]interface{}), nil
}

func formatStringList(strs []string) string {
	if len(strs) == 0 {
		return ""
	}
	
	result := fmt.Sprintf("'%s'", strs[0])
	for i := 1; i < len(strs); i++ {
		result += fmt.Sprintf(", '%s'", strs[i])
	}
	return result
}

func buildFilterExpression(filter map[string]interface{}) string {
	// 简化实现，构建基本的过滤表达式
	// 实际使用中需要更复杂的表达式构建逻辑
	expressions := make([]string, 0)
	
	for key, value := range filter {
		switch v := value.(type) {
		case string:
			expressions = append(expressions, fmt.Sprintf("metadata['%s'] == '%s'", key, v))
		case int:
			expressions = append(expressions, fmt.Sprintf("metadata['%s'] == %d", key, v))
		case float64:
			expressions = append(expressions, fmt.Sprintf("metadata['%s'] == %f", key, v))
		}
	}
	
	if len(expressions) == 0 {
		return ""
	}
	
	result := expressions[0]
	for i := 1; i < len(expressions); i++ {
		result += " and " + expressions[i]
	}
	
	return result
}